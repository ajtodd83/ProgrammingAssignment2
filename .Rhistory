print "YAY! RStudio is open and running!"
library(ggplot2)
install.packages(c("slidify", "ggplot2", "devtools"))
source("http://bioconductor.org/biocLite.R")
biocLite()
biocLite(c("GenomicFeatures", "AnnotationDbi"))
library(ggplot2)
install.packages("ggplot2"))
install.packages("ggplot2")
library(ggplot2)
install.packages("ggplot2")
library(ggplot2)
install.packages("ggplot2")
install.packages("plyr")
install.packages("ggplot2")
library(ggplot2)
sudo installed.packages(ggplot2)
sudo installed.packages("ggplot2")
install.packages("KernSmooth")
library(KernSmooth)
install.packages("slidify")
sudo install.packages("slidify")
print("YAY! R is installed, and RStudio is installed and open!")
install.packages("swirl")
library(datasets)
head(airquality)
s <- split(airquality, airquality$Month)
s
head(s)
lapply(s, function(x) colMeans(x[, c("Ozone", "Solar.R", "Wind")]))
sapply(s, function(x) colMeans(x[, c("Ozone", "Solar.R", "Wind")]))
sapply(s, function(x) colMeans(x[, c("Ozone", "Solar.R", "Wind")]), na.rm = TRUE)
sapply(s, function(x) colMeans(x[, c("Ozone", "Solar.R", "Wind")], na.rm = TRUE))
x <- rnorm(10)
f1 <- gl(2,5)
f2 <- gl(5,2)
f1
f2
interaction(f1, f2)
str(split(x, list(f1, f2)))
x
str(split(x, list(f1, f2), drop = TRUE))
mean(x)
traceback()
lm(y - x)
traceback()
debug(lm)
lm(y-x)
options(error = recover)
read.csv("nosuchfile")
library(datasets)
data(iris)
str(iris)
head(iris)
virginica <- split(iris, virginica)
virginica <- split(iris, "virginica")
virginica
head(virginica)
str(iris)
iris[iris$Species == "virginica",]
virginica <- iris[iris$Species == "virginica",]
virginica
str(virginica)
mean(virginica$Sepal)
str(mean)
virginica$Sepal
virginica[["Sepal.Length"]]
mean(virginica[["Sepal.Length"]])
str(iris)
apply(iris, 2, mean)
apply(iris[,1:4], 2, mean)
apply(iris[,1:4], 1, mean)
library(datasets)
data(mtcars)
?mtcars
head(mtcars)
head(mtcars, 10)
tapply(mtcars$cyl, mtcars$mpg, mean)
lapply(mtcars, mean)
mean(mtcars$mpg, mtcars$cyl)
with(mtcars, tapply(mpg, cyl, mean))
?with
head(mtcars)
with(mtcars, tapply(hp, cyl, mean))
str(with(mtcars, tapply(hp, cyl,mean)))
tapply(iris$Sepal.Length, iris$Species, mean)
apply(iris[,1:4], 2, mean)
}
makeVector <- function(x = numeric()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setmean <- function(mean) m <<- mean
getmean <- function() m
list(set = set, get = get,
setmean = setmean,
getmean = getmean)
}
cachemean <- function(x, ...) {
m <- x$getmean()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- mean(data, ...)
x$setmean(m)
m
}
makeVector
makeVector()
makeVector(c(1,2,3,4))
cachemean
cachemean()
cachemean(makeVector())
cachemean(makeVector(1))
makeVector(!)
makeVector(1)
makeVector.set(c(1, 2, 3, 4))
makeVector[1](c(1, 2, 3, 4))
a <- makeVector(c(1,2,3,4))
a
print a
a <- makeVector(x=c(1,2,3,4))
a
b <- cachemean(a)
b
a[1]
a[1:4]
setwd("~/ProgrammingAssignment2")
?mean
?solve
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
inverse <- NULL
set <- function(y) {
x <<- y
inverse <<- NULL
}
get <- function() x
setinverse <- function(inv) inverse <<- inv
getinverse <- function() inverse
list(set = set, get = get, setinverse = setinverse, getinvese = getinverse)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inverse <- x$getinverse()
if(!is.null(inverse)) {
message("getting cached data")
return(inverse)
}
data <-x$get()
inverse <- solve(data, ...)
x$setinverse(inverse)
inverse
}
c1 <- c(1,0)
c2 <- c(0,1)
identity <- cbind(c1, c2)
identity
makeCacheMatrix$set(identity)
makeCacheMatrix(identity)
cacheSolve(identity)
makeCacheMatrix[1](identity)
makeCacheMatrix(identity)
a <- makeCacheMatrix(identity)
b <- cacheSolve(a)
makeCacheMatrix$set
a <- makeVector(x=c(1,2,3,4))
b <- cachemean(a)
b
a <- makeCacheMatrix(x=identity)
b <- cacheSolve(x=a)
traceback
b <- cacheSolve(x=a)
traceback()
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
inverse <- NULL
set <- function(y) {
x <<- y
inverse <<- NULL
}
get <- function() x
setinverse <- function(inv) inverse <<- inv
getinverse <- function() inverse
list(set = set, get = get, setinverse = setinverse, getinvese = getinverse)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inverse <- x$getinverse()
if(!is.null(inverse)) {
message("getting cached data")
return(inverse)
}
data <-x$get()
inverse <- solve(data, ...)
x$setinverse(inverse)
inverse
}
b <- cacheSolve(x=a)
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
inverse <- NULL
set <- function(y) {
x <<- y
inverse <<- NULL
}
get <- function() x
setinverse <- function(inv) inverse <<- inv
getinverse <- function() inverse
list(set = set, get = get, setinverse = setinverse, getinvese = getinverse)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inverse <- x$getinverse()
if(!is.null(inverse)) {
message("getting cached data")
return(inverse)
}
data <-x$get()
inverse <- solve(data, ...)
x$setinverse(inverse)
inverse
}
a <- makeCacheMatrix(x=identity)
b <- cacheSolve(x=a)
?$
a
a$set(cbind(c1, c2))
a
a$get((cbind(c1, c2))))
a$get()
a$setinverse()
a$getinverse()
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
inverse <- NULL
set <- function(y) {
x <<- y
inverse <<- NULL
}
get <- function() x
setinverse <- function(inv) inverse <<- inv
getinv <- function() inverse
list(set = set, get = get, setinverse = setinverse, getinvese = getinverse)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inverse <- x$getinverse()
if(!is.null(inverse)) {
message("getting cached data")
return(inverse)
}
data <-x$get()
inverse <- solve(data, ...)
x$setinverse(inverse)
inverse
}
a$set(cbind(c1, c2))
a
a$get()
a$set(cbind(c(0, 1), c(1,0))
a$get()
a$set(cbind(c(0, 1), c(1,0)))
a$get()
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
inverse <- NULL
set <- function(y) {
x <<- y
inverse <<- NULL
}
get <- function() x
setinverse <- function(inv) inverse <<- inv
getinv <- function() inverse
list(set = set, get = get, setinverse = setinverse, getinverse = getinverse)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inverse <- x$getinverse()
if(!is.null(inverse)) {
message("getting cached data")
return(inverse)
}
data <-x$get()
inverse <- solve(data, ...)
x$setinverse(inverse)
inverse
}
a$set(cbind(c1, c2))
a$get()
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
inverse <- NULL
set <- function(y) {
x <<- y
inverse <<- NULL
}
get <- function() x
setinverse <- function(inv) inverse <<- inv
getinverse <- function() inverse
list(set = set, get = get, setinverse = setinverse, getinverse = getinverse)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inverse <- x$getinverse()
if(!is.null(inverse)) {
message("getting cached data")
return(inverse)
}
data <-x$get()
inverse <- solve(data, ...)
x$setinverse(inverse)
inverse
}
a$set(cbind(c1, c2))
a$get()
a$getinverse()
a
a <-makeCacheMatrix(cbind(c1,c2))
a
a$get()
a$getinverse()
cacheSolve(a)
a <-makeCacheMatrix(cbind(c(1,2),c(3,4)))
cacheSolve(a)
makeCacheMatrix(cbind(c(1,2),c(3,4)))
makeCacheMatrix
